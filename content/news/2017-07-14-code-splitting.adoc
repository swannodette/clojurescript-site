= Enhanced Code Splitting {amp} Loading
David Nolen
2017-07-14
:jbake-type: post

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

As client applications increase in size it becomes desirable to optimize the
time to load a logical screen. Network requests should be minimized while at the
same the loaded code should be restricted to that which is absolutely necessary
to produce a functioning screen. While tools like
https://webpack.github.io[Webpack] have popularized this optimization technique
in the JavaScript mainstream, Google Closure Compiler and Library have supported
this same optimization strategy in the form of Google Closure Modules for many
years now.

Google Closure Modules also provide some unique advantages over tools
like Webpack or http://rollupjs.org[Rollup] which we will cover in the technical
section of this post. In short, we optimally assign all sources to modules
after which Google Closure Compiler employs dead code elimination (tree shaking)
and cross module code motion to produce truly optimal splits.

While ClojureScript has provided basic integration with this facility,
the next release will feature greatly enhanced and comprehensive support for
code splitting and asynchronous loading of these splits.

If you are familiar with Webpack terminology, in the following description note
that **module** in this context refers to a **code split** or **chunk**.

== Enhanced Code Splitting

It is no longer necessary to hand-optimize module assignment of your sources.
All sources will be optimally assigned to a module based upon the dependency
graph of your application. If you have a module with many manual assignments you
should now remove these. If you were using namespace wildcard matching, this is
also no longer necessary. For details about how we assign an input to a
particular module see the technical description below.

Concretely, the following is an antipattern:

[code,clojure]
```
{:modules
  {:vendor {:output-to "..."
            :entries '#{cljsjs.react reagent.* re-frame.*}}
   :main   {:output-to "..."
            :entries '#{myapp.core}
            :depends-on [:vendor]}}
```

All that is required now is:

[code,clojure]
```
{:modules
  {:vendor {:output-to "..."
            :entries '#{re-frame.core}
   :main   {:output-to "..."
            :entries '#{myapp.core}
            :depends-on [:vendor]}}
```

Another significant enhancement is that `:modules` works under all optimization
settings. By unifying `:modules` behavior under all compilation modes we eliminate
a source of incidental complexity around build configuration between development
and production.

== cljs.loader

Asynhronous loading of module splits is now standardized with the introduction
of the `cljs.loader` namespace. In any entry point that needs to invoke the
load of another module due to some user action, can now do so with `cljs.loader`.

`cljs.loader` provides a shared Google Closure `ModuleManager` singleton which
initialized correctly to your `:modules` graph without additional configuration
regardless of the optimization level.

For a complete walk through of the enhanced `:modules` functionality please
refer the new guide.

== Technical Description

=== Module Assignment

=== Cross Module Code Motion
