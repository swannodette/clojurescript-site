= Enhanced Code Splitting {amp} Loading
David Nolen
2017-07-14
:jbake-type: post

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

As client applications increase in size it becomes desirable to optimize the
time to load a logical screen. Network requests should be minimized while at the
same the loaded code should be restricted to that which is absolutely necessary
to produce a functioning screen. While tools like
https://webpack.github.io[Webpack] have popularized this optimization technique
in the JavaScript mainstream, Google Closure Compiler and Library have supported
this same optimization strategy in the form of Google Closure Modules for many
years now.

Google Closure Modules also provide some unique advantages over tools
like Webpack or http://rollupjs.org[Rollup] which we will cover in the technical
section of this post. In short, we optimally assign all sources to modules
after which Google Closure Compiler employs dead code elimination (tree shaking)
and cross module code motion to produce truly optimal splits.

While ClojureScript has provided basic integration with this facility,
the next release will feature greatly enhanced and comprehensive support for
code splitting and asynchronous loading of these splits.

=== Terminology

If you are familiar with Webpack terminology, in the following description note
that **module** in this context refers to a **code split** or **chunk**.

By *entry point* we mean a source file which represents a logical entry point
into your application (login, users, admin, etc.).

== Enhanced Code Splitting

It is no longer necessary to hand-optimize module assignment of your sources.
All sources will be optimally assigned to a module based upon the dependency
graph of your application. If you have a module with many manual assignments you
should now remove these. If you were using namespace wildcard matching, this is
also no longer necessary. For details about how we assign an input to a
particular module see the technical description below.

Concretely, the following is now an anti-pattern:

[code,clojure]
```
{:modules
  {:vendor {:output-to "..."
            :entries '#{cljsjs.react reagent.* re-frame.*}}
   :main   {:output-to "..."
            :entries '#{myapp.core}
            :depends-on [:vendor]}}
```

All that is required is:

[code,clojure]
```
{:modules
  {:vendor {:output-to "..."
            :entries '#{re-frame.core}
   :main   {:output-to "..."
            :entries '#{myapp.core}
            :depends-on [:vendor]}}
```

Another significant enhancement is that `:modules` works under all optimization
settings. By unifying `:modules` behavior under all compilation modes we eliminate
a source of incidental complexity around build configuration between development
and production.

== cljs.loader

Asynchronous loading of module splits is now standardized with the introduction
of the `cljs.loader` namespace. If any entry point in your application needs
to invoke the load of another module due to some user action, you can now do so
with `cljs.loader`.

`cljs.loader` provides a shared Google Closure
https://google.github.io/closure-library/api/goog.module.ModuleManager.html[ModuleManager]
singleton which initialized correctly to your `:modules` graph without
additional configuration regardless of the optimization level.

The following is a simple short example:

[code,clojure]
```
(ns foo.core
 (:require [cljs.loader :as loader]
           [goog.dom :as gdom]
           [goog.events :as events])
 (:import [goog.events EventType]))

(events/listen (gdom/getElement "button") EventType.CLICK
  (fn [e]
    (loader/load :bar
      (fn [e]
        ((resolve 'bar.core/woz))))))
```

Note that this example shows how to call across module boundaries without
having the compiler complain about functionality not present in this code split.
This is possible thanks to the recent inclusion of static `resolve` to the
standard library.

For a complete walk through of the enhanced `:modules` functionality please
refer the new guide.

== Technical Description

=== Module Assignment

=== Cross Module Code Motion
